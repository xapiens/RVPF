/** Related Values Processing Framework.
 *
 * Copyright (c) 2003-2019 Serge Brisson.
 *
 * This software is distributable under the LGPL license.
 * See details at the bottom of this file.
 *
 * $Id: UUID.java 4110 2019-07-24 18:17:42Z SFB $
 */

package org.rvpf.base;

import java.io.ByteArrayOutputStream;
import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.Serializable;

import java.math.BigInteger;

import java.security.SecureRandom;

import java.util.Arrays;
import java.util.Optional;
import java.util.StringJoiner;
import java.util.regex.Pattern;

import javax.annotation.CheckReturnValue;
import javax.annotation.Nonnull;
import javax.annotation.concurrent.Immutable;

import org.rvpf.base.logger.Message;
import org.rvpf.base.tool.Inet;

/**
 * Universally Unique IDentifier.
 *
 * <p>This class implements version 4 (pseudo-randomly generated) of the RFC
 * 4122 variant of the UUID namespace.</p>
 *
 * <p>Some debugging use cases benefit from being able to identify the machine
 * from which a UUID has been generated. To allow for this, a system property
 * ({@value #MAC_ADDRESS_PROPERTY}) allows the use of the MAC address of a
 * specified or default interface to be used as the node value in each generated
 * UUID, like it would be for a version 1 (time-based) UUID.</p>
 *
 * <p>UUID values are frequently used as primary keys in databases. A special
 * bit manipulation allows the key value to be identified as deleted: the
 * variant field is modified to make the UUID use the NCS compatibility value
 * which is not accepted as valid for original keys where deleted entries may be
 * present.</p>
 */
@Immutable
public final class UUID
    implements Serializable, Comparable<UUID>
{
    /**
     * Constructs an instance.
     *
     * @param bytes Binary value for the UUID in {@value #BYTES_LENGTH} bytes.
     */
    private UUID(@Nonnull final byte[] bytes)
    {
        _bytes = bytes;
    }

    /**
     * Returns a new UUID from a byte array.
     *
     * @param bytes Binary value for the UUID in {@value #BYTES_LENGTH} bytes.
     *
     * @return The new UUID.
     */
    @Nonnull
    @CheckReturnValue
    public static UUID fromBytes(@Nonnull final byte[] bytes)
    {
        if (bytes.length != BYTES_LENGTH) {
            throw new IllegalArgumentException(
                Message.format(
                    BaseMessages.UUID_BYTES_LENGTH,
                    String.valueOf(bytes.length)));
        }

        return new UUID(bytes.clone());
    }

    /**
     * Reads in an external representation of a UUID.
     *
     * @param source The source.
     *
     * @return The UUID (may be empty).
     *
     * @throws IOException When an I/O error occurs.
     */
    @Nonnull
    @CheckReturnValue
    public static Optional<UUID> fromDataInput(
            @Nonnull final DataInput source)
        throws IOException
    {
        final int length = source.readByte();
        final Optional<UUID> uuid;

        if (length > 0) {
            final byte[] bytes = new byte[length];

            source.readFully(bytes);
            uuid = Optional.of(fromBytes(bytes));
        } else {
            uuid = Optional.empty();
        }

        return uuid;
    }

    /**
     * Returns a new UUID from two longs.
     *
     * <p>This convenience method is used to convert from a
     * {@link java.util.UUID}.</p>
     *
     * @param high The most significant bits.
     * @param low The least significant bits.
     *
     * @return The new UUID.
     */
    @Nonnull
    @CheckReturnValue
    public static UUID fromLongs(long high, long low)
    {
        final byte[] bytes = new byte[BYTES_LENGTH];

        for (int i = (BYTES_LENGTH / 2) - 1; i >= 0; --i) {
            bytes[i] = (byte) high;
            high = high >> Byte.SIZE;
        }

        for (int i = BYTES_LENGTH - 1; i >= (BYTES_LENGTH / 2); --i) {
            bytes[i] = (byte) low;
            low = low >> Byte.SIZE;
        }

        return new UUID(bytes);
    }

    /**
     * Returns a new UUID from a name generated by {@link #toName}.
     *
     * @param name The previously generated name.
     *
     * @return The new UUID.
     */
    @Nonnull
    @CheckReturnValue
    public static UUID fromName(@Nonnull String name)
    {
        final byte[] bytes = new byte[BYTES_LENGTH];
        final byte[] buffer;

        name = name.trim();

        try {
            buffer = new BigInteger(name, _NAME_BASE).toByteArray();
        } catch (final NumberFormatException exception) {
            throw new IllegalArgumentException(
                Message.format(BaseMessages.UUID_NAME_BAD, name));
        }

        if ((buffer.length != (BYTES_LENGTH + 1)) || (buffer[0] != (byte) 1)) {
            throw new IllegalArgumentException(
                Message.format(
                    BaseMessages.UUID_NAME_LENGTH,
                    "UUID name '",
                    name));
        }

        System.arraycopy(buffer, 1, bytes, 0, bytes.length);

        return new UUID(bytes);
    }

    /**
     * Returns a new UUID from a string.
     *
     * @param string A string of 32 hexadecimal digits for the UUID. It may
     *               include '-' decorators. When empty, an empty value is
     *               returned.
     *
     * @return The new UUID or empty.
     */
    @Nonnull
    @CheckReturnValue
    public static Optional<UUID> fromString(@Nonnull String string)
    {
        string = string.trim();

        if (string.isEmpty()) {
            return Optional.empty();
        }

        final byte[] bytes = _toBytes(string);

        if ((bytes == null) || (bytes.length != BYTES_LENGTH)) {
            throw new IllegalArgumentException(
                Message.format(BaseMessages.UUID_STRING_INVALID, string));
        }

        return Optional.of(new UUID(bytes));
    }

    /**
     * Generates a UUID.
     *
     * @return The new UUID.
     */
    @Nonnull
    @CheckReturnValue
    public static UUID generate()
    {
        return generate(Optional.empty());
    }

    /**
     * Generates a version 4 UUID (IETF RFC 4122).
     *
     * @param seed A value prefix (may be null).
     *
     * @return The new UUID.
     */
    @Nonnull
    @CheckReturnValue
    public static UUID generate(@Nonnull final Optional<byte[]> seed)
    {
        if (seed.isPresent() && (seed.get().length >= BYTES_LENGTH)) {
            return fromBytes(seed.get());
        }

        final byte[] bytes = _generateBytes();

        if (seed.isPresent()) {
            System.arraycopy(seed.get(), 0, bytes, 0, seed.get().length);
        }

        return new UUID(bytes);
    }

    /**
     * Generates a UUID.
     *
     * @param seed A value prefix (may be empty).
     *
     * @return The new UUID.
     */
    @Nonnull
    @CheckReturnValue
    public static UUID generate(@Nonnull String seed)
    {
        if (seed == null) {
            return generate(Optional.empty());
        }

        seed = seed.trim();

        if (seed.isEmpty()) {
            return generate(Optional.empty());
        }

        final byte[] bytes = _toBytes(seed);

        if (bytes == null) {
            throw new IllegalArgumentException(
                Message.format(BaseMessages.UUID_SEED_INVALID, seed));
        }

        return generate(Optional.of(bytes));
    }

    /**
     * Gets the node part.
     *
     * @return The node part (empty if not a MAC address).
     */
    @Nonnull
    @CheckReturnValue
    public static Optional<byte[]> getNode()
    {
        return _NODE;
    }

    /**
     * Asks if a key string can represent a UUID.
     *
     * @param key The candidate key string.
     *
     * @return A true value if it would be accepted.
     */
    @CheckReturnValue
    public static boolean isUUID(@Nonnull String key)
    {
        key = key.trim();

        final int length = key.length();

        if (length == RAW_STRING_LENGTH) {
            return _RAW_UUID_PATTERN.matcher(key).matches();
        }

        if (length == STRING_LENGTH) {
            return _UUID_PATTERN.matcher(key).matches();
        }

        return false;
    }

    /**
     * Reads in an external representation of a UUID.
     *
     * <p>This is a helper method for
     * {@link java.io.Externalizable Externalizable} objects containing a
     * UUID.</p>
     *
     * @param source The source.
     *
     * @return The optional UUID.
     *
     * @throws IOException When an I/O error occurs.
     */
    @Nonnull
    @CheckReturnValue
    public static Optional<UUID> readExternal(
            @Nonnull final ObjectInput source)
        throws IOException
    {
        return fromDataInput(source);
    }

    /**
     * Synthesizes a UUID from four numbers.
     *
     * @param high A 48 bits number.
     * @param midHigh A 8 bits number.
     * @param midLow A 8 bits number.
     * @param low A 40 bits number.
     *
     * @return The UUID.
     */
    @Nonnull
    @CheckReturnValue
    public static UUID synthesize(
            long high,
            final int midHigh,
            final int midLow,
            long low)
    {
        final ByteArrayOutputStream stream = new ByteArrayOutputStream(
            BYTES_LENGTH);
        final byte[] time = new byte[8];
        final byte[] seq = new byte[2];
        final byte[] node = new byte[6];

        time[0] = (byte) VERSION_4;
        time[1] = (byte) midHigh;

        for (int i = time.length - 1; i > 1; --i) {
            time[i] = (byte) high;
            high >>= 8;
        }

        stream.write(time, 2, 6);
        stream.write(time, 0, 2);

        seq[0] = (byte) VARIANT_4122;
        seq[1] = (byte) midLow;
        stream.write(seq, 0, 2);

        node[0] = MULTICAST_BIT_MASK;

        for (int i = node.length - 1; i > 0; --i) {
            node[i] = (byte) low;
            low >>= 8;
        }

        stream.write(node, 0, 6);

        return new UUID(stream.toByteArray());
    }

    /**
     * Writes out an external representation of a UUID.
     *
     * <p>This is a helper method for
     * {@link java.io.Externalizable Externalizable} objects containing a
     * UUID.</p>
     *
     * @param uuid The UUID (may be empty).
     * @param destination The destination.
     *
     * @throws IOException When an I/O error occurs.
     */
    public static void writeExternal(
            @Nonnull final Optional<UUID> uuid,
            @Nonnull final ObjectOutput destination)
        throws IOException
    {
        if (uuid.isPresent()) {
            uuid.get().toDataOutput(destination);
        } else {
            destination.writeByte(0);
        }
    }

    /**
     * Implements Comparable.
     *
     * @param other An other PointEntity.
     *
     * @return A negative integer, zero, or a positive integer.
     */
    @Override
    public int compareTo(final UUID other)
    {
        int comparison = 0;

        for (int i = 0; i < BYTES_LENGTH; ++i) {
            comparison = (_bytes[i] & 0xFF) - (other._bytes[i] & 0xFF);

            if (comparison != 0) {
                break;
            }
        }

        return comparison;
    }

    /**
     * Returns this or a clone of this with the 'deleted' indicator set.
     *
     * <p>If the 'deleted' indicator is already set, returns this.</p>
     *
     * @return A 'deleted' UUID.
     */
    @Nonnull
    @CheckReturnValue
    public UUID deleted()
    {
        final UUID deleted;

        if (isDeleted()) {
            deleted = this;
        } else {
            final byte[] bytes = _bytes.clone();

            bytes[_VARIANT_OFFSET] &= (byte) ~_DELETED_MASK;
            deleted = new UUID(bytes);
        }

        return deleted;
    }

    /** {@inheritDoc}
     */
    @Override
    public boolean equals(final Object other)
    {
        if (this == other) {
            return true;
        }

        if (other instanceof UUID) {
            return Arrays.equals(_bytes, ((UUID) other)._bytes);
        }

        return false;
    }

    /**
     * Gets back the high value from a synthesized UUID.
     *
     * @return The high value (48 bits).
     */
    @CheckReturnValue
    public long getHigh()
    {
        long high = 0;

        for (int i = 0; i < 6; ++i) {
            high <<= 8;
            high |= _bytes[i] & 0xFF;
        }

        return high;
    }

    /**
     * Gets the least significant bits.
     *
     * <p>This convenience method is used to help convert to
     * {@link java.util.UUID}.</p>
     *
     * @return The least significant bits.
     */
    @CheckReturnValue
    public long getLeastSignificantBits()
    {
        return _toLong(BYTES_LENGTH / 2);
    }

    /**
     * Gets back the low value from a synthesized UUID.
     *
     * @return The low value (40 bits).
     */
    @CheckReturnValue
    public long getLow()
    {
        long low = 0;

        for (int i = 11; i < 16; ++i) {
            low <<= 8;
            low |= _bytes[i] & 0xFF;
        }

        return low;
    }

    /**
     * Gets back the mid high value from a synthesized UUID.
     *
     * @return The mid high value (8 bits).
     */
    @CheckReturnValue
    public int getMidHigh()
    {
        return _bytes[7] & 0xFF;
    }

    /**
     * Gets back the mid low value from a synthesized UUID.
     *
     * @return The mid low value (8 bits).
     */
    @CheckReturnValue
    public int getMidLow()
    {
        return _bytes[9] & 0xFF;
    }

    /**
     * Gets the most significant bits.
     *
     * <p>This convenience method is used to help convert to
     * {@link java.util.UUID}.</p>
     *
     * @return The most significant bits.
     */
    @CheckReturnValue
    public long getMostSignificantBits()
    {
        return _toLong(0);
    }

    /** {@inheritDoc}
     */
    @Override
    public int hashCode()
    {
        return Arrays.hashCode(_bytes);
    }

    /**
     * Asks if this represents a deleted entry.
     *
     * @return A true value if deleted.
     */
    @CheckReturnValue
    public boolean isDeleted()
    {
        return (_bytes[_VARIANT_OFFSET] & _DELETED_MASK) == 0;
    }

    /**
     * Asks if this contains a random node.
     *
     * <p>Note: some UUID generators do not interpret correctly the position of
     * the multicast bit in RFC 4122.</p>
     *
     * @return A true if this contains a random node.
     */
    @CheckReturnValue
    public boolean isRandomNode()
    {
        return (_bytes[_NODE_OFFSET] & MULTICAST_BIT_MASK) != 0;
    }

    /**
     * Returns a binary representation of itself.
     *
     * @return A clone of its bytes.
     */
    @Nonnull
    @CheckReturnValue
    public byte[] toBytes()
    {
        return _bytes.clone();
    }

    /**
     * Sends to a data output.
     *
     * @param destination The destination.
     *
     * @throws IOException On I/O exception.
     */
    public void toDataOutput(
            @Nonnull final DataOutput destination)
        throws IOException

    {
        destination.writeByte(BYTES_LENGTH);
        destination.write(_bytes);
    }

    /**
     * Returns a name representation of itself.
     *
     * @return An undecorated string of 25 base 36 digits.
     */
    @Nonnull
    @CheckReturnValue
    public String toName()
    {
        final byte[] buffer = new byte[BYTES_LENGTH + 1];

        buffer[0] = (byte) 1;    // Ensures first digit is alpha and length is 25.
        System.arraycopy(_bytes, 0, buffer, 1, BYTES_LENGTH);

        return new BigInteger(buffer).toString(_NAME_BASE);
    }

    /**
     * Returns an undecorated string representation of itself.
     *
     * @return An undecorated string of hexadecimal digits.
     */
    @Nonnull
    @CheckReturnValue
    public String toRawString()
    {
        return _toHex(0, BYTES_LENGTH);
    }

    /**
     * Returns a decorated string representation of itself.
     *
     * @return An decorated string of hexadecimal digits.
     */
    @Override
    public String toString()
    {
        final StringJoiner stringJoiner = new StringJoiner("-");

        stringJoiner.add(_toHex(0, 4));
        stringJoiner.add(_toHex(4, 2));
        stringJoiner.add(_toHex(6, 2));
        stringJoiner.add(_toHex(8, 2));
        stringJoiner.add(_toHex(10, 6));

        return stringJoiner.toString();
    }

    /**
     * Returns a URN reference to this.
     *
     * @return The URN reference to this.
     */
    @Nonnull
    @CheckReturnValue
    public String toURN()
    {
        return "urn:uuid:" + toString();
    }

    /**
     * Returns this or a clone of this with the 'deleted' indicator cleared.
     *
     * <p>If the 'deleted' indicator is already clear, returns this.</p>
     *
     * @return An 'undeleted' UUID.
     */
    @Nonnull
    @CheckReturnValue
    public UUID undeleted()
    {
        final UUID undeleted;

        if (isDeleted()) {
            final byte[] bytes = _bytes.clone();

            bytes[_VARIANT_OFFSET] |= (byte) _DELETED_MASK;
            undeleted = new UUID(bytes);
        } else {
            undeleted = this;
        }

        return undeleted;
    }

    private static byte[] _generateBytes()
    {
        final ByteArrayOutputStream stream = new ByteArrayOutputStream(
            BYTES_LENGTH);
        final byte[] time = new byte[8];
        final byte[] seq = new byte[2];
        final byte[] node;

        synchronized (_RANDOM) {
            _RANDOM.nextBytes(time);
            time[0] &= (byte) 0x0F;
            time[0] |= (byte) VERSION_4;

            _RANDOM.nextBytes(seq);
            seq[0] &= (byte) 0x3F;
            seq[0] |= (byte) VARIANT_4122;

            if (_NODE.isPresent()) {
                node = _NODE.get();
            } else {
                node = new byte[6];
                _RANDOM.nextBytes(node);
                node[0] |= MULTICAST_BIT_MASK;
            }
        }

        stream.write(time, 4, 4);
        stream.write(time, 2, 2);
        stream.write(time, 0, 2);
        stream.write(seq, 0, 2);
        stream.write(node, 0, 6);

        return stream.toByteArray();
    }

    private static byte[] _toBytes(final String string)
    {
        final ByteArrayOutputStream stream;

        try {
            final int length = string.length();
            int i = 0;

            stream = new ByteArrayOutputStream(BYTES_LENGTH);

            while (i < length) {
                if (string.charAt(i) == '-') {
                    ++i;
                } else {
                    stream
                        .write(
                            Integer
                                .parseInt(
                                        string.substring(i, i + 2),
                                                _HEX_BASE));
                    i += 2;
                }
            }
        } catch (final NumberFormatException exception) {
            return null;
        } catch (final IndexOutOfBoundsException exception) {
            return null;
        }

        return stream.toByteArray();
    }

    private String _toHex(final int start, final int length)
    {
        final StringBuilder stringBuilder = new StringBuilder(length * 2);

        for (int i = 0; i < length; ++i) {
            final String hexDigits = Integer
                .toHexString(_bytes[start + i] & _BYTE_MASK);

            if (hexDigits.length() < 2) {
                stringBuilder.append('0');
            }

            stringBuilder.append(hexDigits);
        }

        return stringBuilder.toString();
    }

    private long _toLong(final int start)
    {
        long result = 0;

        for (int i = 0; i < (BYTES_LENGTH / 2); ++i) {
            result = result << Byte.SIZE;
            result |= _bytes[start + i] & 0xFF;
        }

        return result;
    }

    /** Length of a byte array containing a UUID. */
    public static final int BYTES_LENGTH = 16;

    /** Include MAC address property (may specify interface). */
    public static final String MAC_ADDRESS_PROPERTY = "rvpf.uuid.mac";

    /** Name length. */
    public static final int NAME_LENGTH = 25;

    /** Null UUID. */
    public static final UUID NULL;

    /** Length of a String containing a raw UUID. */
    public static final int RAW_STRING_LENGTH;

    /** Length of a String containing a decorated UUID. */
    public static final int STRING_LENGTH;

    /**  */

    static final byte MULTICAST_BIT_MASK = 0b0000_0001;
    static final int VARIANT_4122 = 0x80;
    static final int VERSION_4 = 0x40;

    /**  */

    private static final int _BYTE_MASK = 0xFF;
    private static final int _DELETED_MASK = 0x80;
    private static final int _HEX_BASE = 16;
    private static final int _NAME_BASE = 36;
    private static final Optional<byte[]> _NODE;
    private static final int _NODE_OFFSET = 10;
    private static final Pattern _RAW_UUID_PATTERN;
    private static final Pattern _UUID_PATTERN;
    private static final int _VARIANT_OFFSET = 8;
    private static final SecureRandom _RANDOM = new SecureRandom();

    /**  */

    private static final long serialVersionUID = 1L;

    static {
        NULL = new UUID(new byte[BYTES_LENGTH]);

        RAW_STRING_LENGTH = BYTES_LENGTH * 2;
        STRING_LENGTH = RAW_STRING_LENGTH + 4;

        final String macInterface = System.getProperty(MAC_ADDRESS_PROPERTY);
        Optional<byte[]> node = Optional.empty();

        if (macInterface != null) {
            node = Inet.getHardwareAddress(Optional.of(macInterface.trim()));

            if (node.isPresent() && (node.get().length != 6)) {
                node = Optional.empty();    // Does not look like a MAC address.
            }
        }

        _NODE = node;

        _RAW_UUID_PATTERN = Pattern
            .compile("[0-9A-F]{32}", Pattern.CASE_INSENSITIVE);

        _UUID_PATTERN = Pattern
            .compile(
                "[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}",
                Pattern.CASE_INSENSITIVE);
    }

    private final byte[] _bytes;
}

/* This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA
 */
