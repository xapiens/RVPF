/** Related Values Processing Framework.
 *
 * Copyright (c) 2003-2019 Serge Brisson.
 *
 * This software is distributable under the LGPL license.
 * See details at the bottom of this file.
 *
 * $Id: StoreValues.java 4095 2019-06-24 17:44:43Z SFB $
 */

package org.rvpf.base.store;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Objects;
import java.util.Optional;

import javax.annotation.CheckReturnValue;
import javax.annotation.Nonnull;
import javax.annotation.concurrent.NotThreadSafe;

import org.rvpf.base.DateTime;
import org.rvpf.base.Points;
import org.rvpf.base.UUID;
import org.rvpf.base.tool.Require;
import org.rvpf.base.value.PointValue;
import org.rvpf.base.value.VersionedValue;

/**
 * Store values.
 *
 * <p>A store values instance is created by a store server to hold the point
 * values generated by the processing of a store query.</p>
 *
 * <p>When a query generates too many values for a single response, the store
 * values contains a {@link org.rvpf.base.store.StoreValuesQuery.Mark Mark}
 * which can be used to generate a new query to get the next values.</p>
 *
 * <p>Instead of point values, a store values instance may contain an exception
 * that will explain what went wrong with the query.</p>
 */
@NotThreadSafe
public final class StoreValues
    extends AbstractCollection<PointValue>
    implements Externalizable
{
    /**
     * Constructs an instance.
     *
     * <p>A default constructor as required for an externalizable.</p>
     */
    public StoreValues() {}

    /**
     * Constructs an instance.
     *
     * @param exception The exception preventing a positive response.
     */
    public StoreValues(@Nonnull final Exception exception)
    {
        _exception = exception;
    }

    /**
     * Constructs a store values.
     *
     * @param query The store query selecting this.
     */
    public StoreValues(@Nonnull final StoreValuesQuery query)
    {
        _query = query;
    }

    /**
     * Adds a point value.
     *
     * @param pointValue The point value.
     *
     * @return True.
     */
    @Override
    public boolean add(final PointValue pointValue)
    {
        return _pointValues.add(Require.notNull(pointValue));
    }

    /** {@inheritDoc}
     */
    @Override
    public void clear()
    {
        _pointValues.clear();
    }

    /**
     * Creates a store query to get further values.
     *
     * <p>This is used by a store's client when receiving a response with a
     * {@link org.rvpf.base.store.StoreValuesQuery.Mark Mark}.</p>
     *
     * @return The new store query.
     */
    @Nonnull
    @CheckReturnValue
    public StoreValuesQuery createQuery()
    {
        return _mark.createQuery();
    }

    /** {@inheritDoc}
     */
    @Override
    public boolean equals(final Object object)
    {
        if (!(object instanceof StoreValues)) {
            return false;
        }

        final StoreValues other = (StoreValues) object;

        if (size() != other.size()) {
            return false;
        }

        final Iterator<PointValue> iterator = other.iterator();

        for (final PointValue pointValue: this) {
            final PointValue otherValue = iterator.next();

            if (!Objects.equals(pointValue.getPoint(), otherValue.getPoint())) {
                return false;
            }

            if (!Objects
                .equals(pointValue.getPointUUID(), otherValue.getPointUUID())) {
                return false;
            }

            if (!Objects.equals(pointValue.getStamp(), otherValue.getStamp())) {
                return false;
            }

            if (!Objects.equals(pointValue.getState(), otherValue.getState())) {
                return false;
            }

            if (!Objects.equals(pointValue.getValue(), otherValue.getValue())) {
                return false;
            }
        }

        return true;
    }

    /**
     * Gets the count of values.
     *
     * @return The count of values.
     */
    @CheckReturnValue
    public long getCount()
    {
        return _count;
    }

    /**
     * Gets the exception.
     *
     * @return The exception (empty on success).
     */
    @Nonnull
    @CheckReturnValue
    public Optional<Exception> getException()
    {
        return Optional.ofNullable(_exception);
    }

    /**
     * Gets the first point value.
     *
     * @return The first point value or empty.
     */
    @Nonnull
    @CheckReturnValue
    public Optional<PointValue> getFirstPointValue()
    {
        return (_pointValues
            .isEmpty()? Optional
                .empty(): Optional.ofNullable(_pointValues.get(0)));
    }

    /**
     * Gets the last point value.
     *
     * @return The last point value or empty.
     */
    @Nonnull
    @CheckReturnValue
    public Optional<PointValue> getLastPointValue()
    {
        return (_pointValues
            .isEmpty()? Optional
                .empty(): Optional
                    .ofNullable(_pointValues.get(_pointValues.size() - 1)));
    }

    /**
     * Gets the mark.
     *
     * @return The optional mark.
     */
    @Nonnull
    @CheckReturnValue
    public Optional<StoreValuesQuery.Mark> getMark()
    {
        return Optional.ofNullable(_mark);
    }

    /**
     * Gets the single point value.
     *
     * @return The single point value or empty.
     */
    @Nonnull
    @CheckReturnValue
    public Optional<PointValue> getPointValue()
    {
        Require.failure(_pointValues.size() > 1, "Multiples values in Response");

        return getFirstPointValue();
    }

    /**
     * Gets a specified point value.
     *
     * @param index The index of the point value.
     *
     * @return The point value.
     */
    @CheckReturnValue
    public PointValue getPointValue(final int index)
    {
        return _pointValues.get(index);
    }

    /**
     * Gets the point values.
     *
     * @return The point values.
     */
    @CheckReturnValue
    public List<PointValue> getPointValues()
    {
        return Collections.unmodifiableList(_pointValues);
    }

    /**
     * Gets the store query.
     *
     * @return Returns the optional store query.
     */
    @Nonnull
    @CheckReturnValue
    public Optional<StoreValuesQuery> getQuery()
    {
        return Optional.ofNullable(_query);
    }

    /** {@inheritDoc}
     */
    @Override
    public int hashCode()
    {
        throw new UnsupportedOperationException();
    }

    /**
     * Asks if this response is complete.
     *
     * <p>When the response to a query is not complete, it contains a
     * {@link org.rvpf.base.store.StoreValuesQuery.Mark Mark} which can be used
     * to create a query for the next values.</p>
     *
     * @return True when this response is complete.
     */
    @CheckReturnValue
    public boolean isComplete()
    {
        return _mark == null;
    }

    /** {@inheritDoc}
     */
    @Override
    public boolean isEmpty()
    {
        return _pointValues.isEmpty();
    }

    /**
     * Asks if this a success response.
     *
     * @return True for a success response.
     */
    @CheckReturnValue
    public boolean isSuccess()
    {
        return _exception == null;
    }

    /**
     * Returns a list iterator on the point values.
     *
     * @return The list iterator on the point values.
     */
    @Override
    public ListIterator<PointValue> iterator()
    {
        return _pointValues.listIterator();
    }

    /**
     * Creates a mark for the next point value.
     *
     * <p>Used when pulling values.</p>
     *
     * @param limit The maximum number of values.
     *
     * @return The optional mark.
     */
    @Nonnull
    @CheckReturnValue
    public Optional<StoreValuesQuery.Mark> mark(final int limit)
    {
        Require
            .success(
                (_query == null)
                || (_query.isPull() && (_query.getPointUUID() == null)));

        if ((_mark == null) && !_pointValues.isEmpty()) {
            final VersionedValue lastValue =
                (VersionedValue) getLastPointValue()
                    .get();
            final StoreValuesQuery.Builder storeQueryBuilder = StoreValuesQuery
                .newBuilder();

            if (_query != null) {
                storeQueryBuilder.copyFrom(_query);
            }

            _query = storeQueryBuilder.setPull(true).setLimit(limit).build();
            _mark = _query
                .newMark(Optional.empty(), lastValue.getVersion().after(), 0);
        }

        return Optional.ofNullable(_mark);
    }

    /**
     * Creates a mark for the next point value.
     *
     * <p>Used by a store server when the store query's limit for the number of
     * values is exceeded.</p>
     *
     * @param pointValue The next point value.
     * @param done The number of values already produced.
     */
    public void mark(@Nonnull final PointValue pointValue, final int done)
    {
        final DateTime stamp;

        if (_query.isPull()) {
            Require.success(pointValue instanceof VersionedValue);
            stamp = ((VersionedValue) pointValue).getVersion();
        } else {
            stamp = pointValue.getStamp();
        }

        _mark = _query.newMark(_query.getPointUUID(), stamp, done);
    }

    /**
     * Creates a mark for the next point value.
     *
     * @param pointUUID The optional UUID of the point of the next value.
     * @param stamp The time stamp of the next value.
     * @param done The number of values already produced.
     */
    public void mark(
            @Nonnull final Optional<UUID> pointUUID,
            @Nonnull final DateTime stamp,
            final int done)
    {
        _mark = _query.newMark(pointUUID, stamp, done);
    }

    /**
     * Reads in an external representation of this.
     *
     * @param input The external representation.
     *
     * @throws IOException When an I/O error occurs.
     * @throws ClassNotFoundException From {@link ObjectInput#readObject}.
     */
    @Override
    public void readExternal(
            final ObjectInput input)
        throws IOException, ClassNotFoundException
    {
        _exception = (Exception) input.readObject();

        _count = input.readLong();

        final int valuesSize = input.readInt();

        for (int i = 0; i < valuesSize; ++i) {
            _pointValues.add((PointValue) input.readObject());
        }

        _mark = StoreValuesQuery.Builder.readMark(input).orElse(null);
    }

    /**
     * Restores the references to the point definitions.
     *
     * @param points The points definitions.
     */
    public void restore(@Nonnull final Points points)
    {
        final ListIterator<PointValue> iterator = _pointValues.listIterator();

        while (iterator.hasNext()) {
            final PointValue pointValue = iterator.next();

            if (pointValue != null) {
                iterator.set(pointValue.restore(points));
            }
        }
    }

    /**
     * Reverses the order of values.
     */
    public void reverse()
    {
        Collections.reverse(_pointValues);
    }

    /**
     * Sets the count of values.
     *
     * @param count The count of values.
     */
    public void setCount(final long count)
    {
        _count = count;
    }

    /**
     * Sets the exception.
     *
     * @param exception The exception.
     */
    public void setException(@Nonnull final Exception exception)
    {
        _exception = exception;
    }

    /**
     * Sets the store query.
     *
     * @param query The optional store query.
     */
    public void setQuery(@Nonnull final Optional<StoreValuesQuery> query)
    {
        _query = query.orElse(null);
    }

    /**
     * Returns the number of values in this Response.
     *
     * @return The number of values.
     */
    @Override
    public int size()
    {
        return _pointValues.size();
    }

    /** {@inheritDoc}
     */
    @Override
    public String toString()
    {
        final StringBuilder stringBuilder = new StringBuilder();

        if (getException().isPresent()) {
            stringBuilder.append("Exception: ");
            stringBuilder.append(getException().get());
        } else {
            stringBuilder.append("Values size: ");
            stringBuilder.append(size());
            stringBuilder.append(" (");

            if (isComplete()) {
                stringBuilder.append("complete");
            } else {
                stringBuilder.append("next: ");
                stringBuilder.append(getMark().get().getStamp());
            }

            stringBuilder.append(")");
        }

        return stringBuilder.toString();
    }

    /**
     * Writes out an external representation of this.
     *
     * @param output The external representation.
     *
     * @throws IOException When an I/O error occurs.
     */
    @Override
    public void writeExternal(final ObjectOutput output)
        throws IOException
    {
        output.writeObject(_exception);

        output.writeLong(_count);

        output.writeInt(_pointValues.size());

        for (final PointValue pointValue: _pointValues) {
            output.writeObject(pointValue);
        }

        StoreValuesQuery.Builder.writeMark(Optional.ofNullable(_mark), output);
    }

    private static final long serialVersionUID = 1L;

    private long _count = -1;
    private Exception _exception;
    private StoreValuesQuery.Mark _mark;
    private final ArrayList<PointValue> _pointValues =
        new ArrayList<PointValue>();
    private transient StoreValuesQuery _query;
}

/* This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA
 */
