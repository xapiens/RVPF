/** Related Values Processing Framework.
 *
 * Copyright (c) 2003-2019 Serge Brisson.
 *
 * This software is distributable under the LGPL license.
 * See details at the bottom of this file.
 *
 * $Id: StoreStatement.java 4095 2019-06-24 17:44:43Z SFB $
 */

package org.rvpf.jdbc;

import java.io.Serializable;

import java.sql.BatchUpdateException;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;

import javax.annotation.CheckReturnValue;
import javax.annotation.Nonnull;

import org.rvpf.base.DateTime;
import org.rvpf.base.UUID;
import org.rvpf.base.logger.Logger;
import org.rvpf.base.rmi.ServiceClosedException;
import org.rvpf.base.rmi.SessionException;
import org.rvpf.base.store.PointBinding;
import org.rvpf.base.store.StoreValues;
import org.rvpf.base.store.StoreValuesQuery;
import org.rvpf.base.tool.Require;
import org.rvpf.base.value.PointValue;
import org.rvpf.base.value.VersionedValue;

/**
 * Store statement.
 */
class StoreStatement
    implements Statement
{
    /**
     * Constructs an instance.
     *
     * @param connection The store connection.
     * @param type The result set type.
     * @param concurrency The result set concurrency.
     * @param holdability The result set holdability.
     */
    StoreStatement(
            @Nonnull final StoreConnection connection,
            final int type,
            final int concurrency,
            final int holdability)
    {
        _connection = connection;
        _type = type;
        _concurrency = concurrency;
        _holdability = holdability;
    }

    /** {@inheritDoc}
     */
    @Override
    public final void addBatch(final String sql)
        throws SQLException
    {
        assertOpen();
        endResults();
        clearWarnings();

        addBatch(_parser.parseSQL(sql, Optional.empty()));
    }

    /** {@inheritDoc}
     */
    @Override
    public final void cancel()
        throws SQLException
    {
        assertOpen();
    }

    /** {@inheritDoc}
     */
    @Override
    public final void clearBatch()
        throws SQLException
    {
        assertOpen();

        if (_batch != null) {
            _batch.clear();
        }
    }

    /** {@inheritDoc}
     */
    @Override
    public final synchronized void clearWarnings()
        throws SQLException
    {
        assertOpen();

        _warnings = null;
    }

    /** {@inheritDoc}
     */
    @Override
    public final void close()
        throws SQLException
    {
        if (_closed.compareAndSet(false, true)) {
            endResults();
            _connection.statementClosed(this);
        }
    }

    /** {@inheritDoc}
     */
    @Override
    public void closeOnCompletion()
        throws SQLException
    {
        throw JDBCMessages.FEATURE_NOT_SUPPORTED.exception();
    }

    /** {@inheritDoc}
     */
    @Override
    public final boolean execute(final String sql)
        throws SQLException
    {
        assertOpen();
        endResults();
        clearWarnings();

        return execute(
            _parser.parseSQL(sql, Optional.empty()),
            Optional.empty());
    }

    /** {@inheritDoc}
     */
    @Override
    public final boolean execute(
            final String sql,
            final int autoGeneratedKeys)
        throws SQLException
    {
        return execute(sql);
    }

    /** {@inheritDoc}
     */
    @Override
    public final boolean execute(
            final String sql,
            final int[] columnIndexes)
        throws SQLException
    {
        return execute(sql);
    }

    /** {@inheritDoc}
     */
    @Override
    public final boolean execute(
            final String sql,
            final String[] columnNames)
        throws SQLException
    {
        return execute(sql);
    }

    /** {@inheritDoc}
     */
    @Override
    public final int[] executeBatch()
        throws SQLException
    {
        assertOpen();
        endResults();
        clearWarnings();

        final int[] updateCounts = new int[(_batch != null)? _batch.size(): 0];
        int index = 0;

        try {
            while (index < updateCounts.length) {
                updateCounts[index++] = executeUpdate(_batch.removeFirst());
            }
        } catch (final SQLException exception) {
            final int[] completedCounts = new int[index];
            final BatchUpdateException batchException = new BatchUpdateException(completedCounts);

            System.arraycopy(updateCounts, 0, completedCounts, 0, index);
            batchException.setNextException(exception);

            throw batchException;
        }

        return updateCounts;
    }

    /** {@inheritDoc}
     */
    @Override
    public final ResultSet executeQuery(final String sql) throws SQLException
    {
        assertOpen();
        endResults();
        clearWarnings();

        final Request request = _parser.parseSQL(sql, Optional.empty());

        if (!request.isQuery()) {
            throw JDBCMessages.NO_RESULT_SET.exception(request.getCommandToken());
        }

        return executeQuery((Request.Query) request, Optional.empty());
    }

    /** {@inheritDoc}
     */
    @Override
    public final int executeUpdate(final String sql) throws SQLException
    {
        assertOpen();
        endResults();
        clearWarnings();

        final Request request = _parser.parseSQL(sql, Optional.empty());

        if (!request.isUpdate()) {
            throw JDBCMessages.NOT_AN_UPDATE.exception(request.getCommandToken());
        }

        return executeUpdate((Request.Update) request);
    }

    /** {@inheritDoc}
     */
    @Override
    public final int executeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException
    {
        return executeUpdate(sql);
    }

    /** {@inheritDoc}
     */
    @Override
    public final int executeUpdate(final String sql, final int[] columnIndexes) throws SQLException
    {
        return executeUpdate(sql);
    }

    /** {@inheritDoc}
     */
    @Override
    public final int executeUpdate(final String sql, final String[] columnNames) throws SQLException
    {
        return executeUpdate(sql);
    }

    /** {@inheritDoc}
     */
    @Override
    public final StoreConnection getConnection() throws SQLException
    {
        assertOpen();

        return _connection;
    }

    /** {@inheritDoc}
     */
    @Override
    public final int getFetchDirection() throws SQLException
    {
        assertOpen();

        return ResultSet.FETCH_FORWARD;
    }

    /** {@inheritDoc}
     */
    @Override
    public final int getFetchSize() throws SQLException
    {
        assertOpen();

        return _fetchSize;
    }

    /** {@inheritDoc}
     */
    @Override
    public final ResultSet getGeneratedKeys() throws SQLException
    {
        assertOpen();

        return _connection.createResultSet();
    }

    /** {@inheritDoc}
     */
    @Override
    public final int getMaxFieldSize() throws SQLException
    {
        assertOpen();

        return 0;
    }

    /** {@inheritDoc}
     */
    @Override
    public final int getMaxRows() throws SQLException
    {
        assertOpen();

        return _maxRows;
    }

    /** {@inheritDoc}
     */
    @Override
    public final boolean getMoreResults() throws SQLException
    {
        assertOpen();

        endResults();

        return false;
    }

    /** {@inheritDoc}
     */
    @Override
    public final boolean getMoreResults(final int current) throws SQLException
    {
        assertOpen();

        if (current == KEEP_CURRENT_RESULT) {
            _resultSet = null;
        }

        return getMoreResults();
    }

    /** {@inheritDoc}
     */
    @Override
    public final int getQueryTimeout() throws SQLException
    {
        assertOpen();

        return 0;
    }

    /** {@inheritDoc}
     */
    @Override
    public final ResultSet getResultSet() throws SQLException
    {
        assertOpen();

        return _resultSet;
    }

    /** {@inheritDoc}
     */
    @Override
    public final int getResultSetConcurrency() throws SQLException
    {
        assertOpen();

        return _concurrency;
    }

    /** {@inheritDoc}
     */
    @Override
    public final int getResultSetHoldability() throws SQLException
    {
        return _holdability;
    }

    /** {@inheritDoc}
     */
    @Override
    public final int getResultSetType() throws SQLException
    {
        assertOpen();

        return _type;
    }

    /** {@inheritDoc}
     */
    @Override
    public final int getUpdateCount() throws SQLException
    {
        assertOpen();

        return _updateCount;
    }

    /** {@inheritDoc}
     */
    @Override
    public final synchronized SQLWarning getWarnings() throws SQLException
    {
        assertOpen();

        return _warnings;
    }

    /** {@inheritDoc}
     */
    @Override
    public boolean isCloseOnCompletion() throws SQLException
    {
        throw JDBCMessages.FEATURE_NOT_SUPPORTED.exception();
    }

    /** {@inheritDoc}
     */
    @Override
    public final boolean isClosed() throws SQLException
    {
        return _closed.get();
    }

    /** {@inheritDoc}
     */
    @Override
    public final boolean isPoolable() throws SQLException
    {
        assertOpen();

        return false;
    }

    /** {@inheritDoc}
     */
    @Override
    public final boolean isWrapperFor(final Class<?> iface) throws SQLException
    {
        return false;
    }

    /** {@inheritDoc}
     */
    @Override
    public final void setCursorName(final String name) throws SQLException
    {
        assertOpen();

        throw JDBCMessages.FEATURE_NOT_SUPPORTED.exception();
    }

    /** {@inheritDoc}
     */
    @Override
    public final void setEscapeProcessing(final boolean enable) throws SQLException
    {
        assertOpen();

        _escapeProcessing = enable;
    }

    /** {@inheritDoc}
     */
    @Override
    public final void setFetchDirection(final int direction) throws SQLException
    {
        assertOpen();

        if (direction != ResultSet.FETCH_FORWARD) {
            throw JDBCMessages.FEATURE_NOT_SUPPORTED.exception();
        }
    }

    /** {@inheritDoc}
     */
    @Override
    public final void setFetchSize(final int rows) throws SQLException
    {
        assertOpen();

        _fetchSize = rows;
    }

    /** {@inheritDoc}
     */
    @Override
    public final void setMaxFieldSize(final int max) throws SQLException
    {
        assertOpen();

        throw JDBCMessages.FEATURE_NOT_SUPPORTED.exception();
    }

    /** {@inheritDoc}
     */
    @Override
    public final void setMaxRows(final int maxRows) throws SQLException
    {
        assertOpen();

        if (maxRows < 0) {
            throw JDBCMessages.INVALID_ARGUMENT.exception("MaxRows");
        }

        _maxRows = maxRows;
    }

    /** {@inheritDoc}
     */
    @Override
    public void setPoolable(final boolean poolable) throws SQLException {}

    /** {@inheritDoc}
     */
    @Override
    public final void setQueryTimeout(final int seconds) throws SQLException
    {
        assertOpen();

        throw JDBCMessages.FEATURE_NOT_SUPPORTED.exception();
    }

    /** {@inheritDoc}
     */
    @Override
    public final <T> T unwrap(final Class<T> iface) throws SQLException
    {
        throw JDBCMessages.FEATURE_NOT_SUPPORTED.exception();
    }

    /**
     * Adds a request to the batch list.
     *
     * @param request The request.
     *
     * @throws SQLException When the request is not an update.
     */
    final void addBatch(@Nonnull final Request request) throws SQLException
    {
        if (!request.isUpdate()) {
            throw JDBCMessages.NOT_AN_UPDATE.exception(request.getCommandToken());
        }

        if (_batch == null) {
            _batch = new LinkedList<Request.Update>();
        }

        _batch.add((Request.Update) request);
    }

    /**
     * Asserts that this statement is open.
     *
     * @throws SQLException If this statement is closed.
     */
    final void assertOpen() throws SQLException
    {
        if (isClosed()) {
            throw JDBCMessages.STATEMENT_CLOSED.exception();
        }
    }

    /**
     * Ends the results.
     *
     * @throws SQLException On failure.
     */
    final void endResults() throws SQLException
    {
        final StoreResultSet resultSet = _resultSet;

        if (resultSet != null) {
            resultSet.close();
            Require.success(_resultSet == null);
        }

        _updateCount = -1;
    }

    /**
     * Executes a request.
     *
     * @param request The request.
     * @param metaData The result set metadata.
     *
     * @return True if the execution produced a result set.
     *
     * @throws SQLException On failure.
     */
    @CheckReturnValue
    final boolean execute(final Request request, final Optional<StoreResultSetMetaData> metaData) throws SQLException
    {
        if (request.isQuery()) {
            executeQuery((Request.Query) request, metaData);
        } else if (request.isUpdate()) {
            executeUpdate((Request.Update) request);
        } else {
            throw new InternalError("Unexpected request");
        }

        return _resultSet != null;
    }

    /**
     * Executes the parsed query.
     *
     * @param queryRequest The query request.
     * @param metaData The result set metadata.
     *
     * @return A result set.
     *
     * @throws SQLException On failure.
     */
    @Nonnull
    final ResultSet executeQuery(@Nonnull final Request.Query queryRequest, @Nonnull final Optional<StoreResultSetMetaData> metaData) throws SQLException
    {
        final StoreResultSet resultSet = new StoreResultSet(_connection, this, queryRequest, metaData);
        Optional<StoreValuesQuery> storeQuery = Optional.empty();

        if (queryRequest.getTableName().orElse(null) == StoreDriver.ARCHIVE_TABLE) {
            storeQuery = Optional.of(queryRequest.prepareStoreQuery(_connection));

            final Optional<UUID> pointUUID = storeQuery.get().getPointUUID();

            if (pointUUID.isPresent()) {
                if (!_connection.getPointName(pointUUID.get()).isPresent()) {
                    storeQuery = Optional.empty();
                }
            } else {
                _connection.getPointsUUID(PointBinding.Request.newBuilder().build());
            }

            if (_maxRows > 0) {
                if (storeQuery.isPresent() && (storeQuery.get().getRows() > _maxRows)) {
                    storeQuery = Optional.of(StoreValuesQuery.newBuilder().copyFrom(storeQuery.get()).setRows(_maxRows).build());
                }
            }
        } else {
            _fetchPointRows(queryRequest, resultSet);
        }

        resultSet.setStoreQuery(storeQuery);
        _resultSet = resultSet;

        return _resultSet;
    }

    /**
     * Executes the parsed update.
     *
     * @param updateRequest The update request.
     *
     * @return The number of updated rows.
     *
     * @throws SQLException On failure.
     */
    final int executeUpdate(@Nonnull final Request.Update updateRequest) throws SQLException
    {
        _updateCount = 0;

        try {
            if (updateRequest.isInsert()) {
                _executeInsert(updateRequest);
            } else if (!updateRequest.getPointColumn().isPresent()) {
                throw JDBCMessages.POINT_NOT_SPECIFIED.exception();
            } else if (updateRequest.isDelete()) {
                _executeDelete(updateRequest);
            } else {
                StoreValuesQuery storeQuery = updateRequest.prepareStoreQuery(_connection);

                for (;;) {
                    final StoreValues storeResponse;

                    try {
                        storeResponse = _connection.getStoreSession().select(storeQuery).orElse(null);

                        if (storeResponse == null) {
                            throw new ServiceClosedException();
                        }
                    } catch (final SessionException exception) {
                        throw JDBCMessages.SESSION_EXCEPTION.wrap(exception);
                    }

                    final List<PointValue> pointValues = storeResponse.getPointValues();
                    final List<PointValue> updateValues = new ArrayList<PointValue>(pointValues.size());

                    for (final PointValue pointValue: pointValues) {
                        final Iterator<StoreColumn> columnsIterator = updateRequest.getColumns().iterator();
                        final PointValue updateValue = pointValue.copy();

                        for (final Token token: updateRequest.getValueTokens()) {
                            switch (columnsIterator.next()) {
                                case VALUE: {
                                    updateValue.setValue(token.getValue());

                                    break;
                                }
                                case STATE: {
                                    updateValue.setState(token.getValue());

                                    break;
                                }
                                default: {
                                    throw new InternalError("Unexpected token: " + token);
                                }
                            }
                        }

                        updateValues.add(updateValue);
                    }

                    update(updateValues.toArray(new PointValue[updateValues.size()]));

                    if (storeResponse.isComplete()) {
                        break;
                    }

                    storeQuery = storeResponse.createQuery();
                }
            }
        } catch (final SQLException exception) {
            _connection.failTransaction();

            throw exception;
        }

        return _updateCount;
    }

    /**
     * Gets the escape processing indicator.
     *
     * @return The escape processing indicator.
     */
    @CheckReturnValue
    final boolean getEscapeProcessing()
    {
        return _escapeProcessing;
    }

    /**
     * Gets the parser.
     *
     * @return The parser.
     */
    @Nonnull
    @CheckReturnValue
    final Parser getParser()
    {
        return _parser;
    }

    /**
     * Gets the logger.
     *
     * @return The logger.
     */
    @Nonnull
    @CheckReturnValue
    final Logger getThisLogger()
    {
        Logger logger = _logger;

        if (logger == null) {
            logger = Logger.getInstance(getClass());
            _logger = logger;
        }

        return logger;
    }

    /**
     * Called by store result sets when they close.
     *
     * @param resultSet The store result set.
     */
    final void resultSetClosed(@Nonnull final StoreResultSet resultSet)
    {
        _resultSet = null;
    }

    /**
     * Updates the specified point values.
     *
     * @param pointValues The point values.
     *
     * @throws SQLException When appropriate.
     */
    final void update(@Nonnull final PointValue[] pointValues) throws SQLException
    {
        int updates = pointValues.length;

        if (_connection.getAutoCommit()) {
            final Exception[] exceptions;

            try {
                exceptions = _connection.getStoreSession().update(pointValues);
            } catch (final SessionException exception) {
                throw JDBCMessages.SESSION_EXCEPTION.wrap(exception);
            }

            for (int i = 0; i < pointValues.length; ++i) {
                final Exception exception = exceptions[i];

                if (exception == null) {
                    if (getThisLogger().isDebugEnabled()) {
                        final PointValue pointValue = pointValues[i];

                        if (!pointValue.getPointName().isPresent()) {
                            pointValue
                                .setPointName(
                                    _connection
                                        .getPointName(pointValue.getPointUUID())
                                        .orElse(null));
                        }

                        getThisLogger().debug(JDBCMessages.UPDATED, pointValue);
                    }
                } else {
                    _addWarning(exception.getMessage());
                    --updates;
                    getThisLogger()
                        .warn(
                            JDBCMessages.UPDATE_FAILED,
                            exception.getMessage());
                }
            }
        } else {
            _connection.addUpdates(pointValues);

            if (getThisLogger().isDebugEnabled()) {
                for (final PointValue pointValue: pointValues) {
                    if (!pointValue.getPointName().isPresent()) {
                        pointValue
                            .setPointName(
                                _connection
                                    .getPointName(pointValue.getPointUUID())
                                    .orElse(null));
                    }

                    getThisLogger()
                        .debug(JDBCMessages.UPDATE_QUEUED, pointValue);
                }
            }
        }

        _updateCount += updates;
    }

    private void _addWarning(final String message)
    {
        final SQLWarning warning = new SQLWarning(message);

        if (_warnings == null) {
            _warnings = warning;
        } else {
            _warnings.setNextWarning(warning);
        }
    }

    private void _executeDelete(final Request request)
        throws SQLException
    {
        StoreValuesQuery storeQuery = request.prepareStoreQuery(_connection);

        for (;;) {
            final StoreValues storeResponse;

            try {
                storeResponse = _connection
                    .getStoreSession()
                    .select(storeQuery)
                    .orElse(null);

                if (storeResponse == null) {
                    throw new ServiceClosedException();
                }
            } catch (final SessionException exception) {
                throw JDBCMessages.SESSION_EXCEPTION.wrap(exception);
            }

            final PointValue[] deletedValues =
                new PointValue[storeResponse.size()];
            final Iterator<PointValue> responseIterator = storeResponse
                .iterator();

            for (int i = 0; i < deletedValues.length; ++i) {
                deletedValues[i] = new VersionedValue.Deleted(
                    responseIterator.next());
            }

            update(deletedValues);

            if (storeResponse.isComplete()) {
                break;
            }

            storeQuery = storeResponse.createQuery();
        }
    }

    private void _executeInsert(
            final Request.Update request)
        throws SQLException
    {
        final List<StoreColumn> columns = request.getColumns();
        final List<Token> values = request.getValueTokens();
        final Iterator<Token> valuesIterator = values.iterator();
        final PointValue[] pointValues =
            new PointValue[values.size() / columns.size()];
        int updates = 0;

        while (valuesIterator.hasNext()) {
            final PointValue pointValue = new PointValue();

            for (final StoreColumn column: columns) {
                final Serializable value = valuesIterator.next().getValue();

                switch (column) {
                    case POINT: {
                        final UUID uuid;

                        if (value instanceof UUID) {
                            uuid = (UUID) value;
                        } else if (value instanceof String) {
                            if (UUID.isUUID((String) value)) {
                                uuid = UUID.fromString((String) value).get();
                            } else {
                                uuid = _connection
                                    .getPointUUID((String) value)
                                    .orElse(null);

                                if (uuid == null) {
                                    throw JDBCMessages.UNKNOWN_POINT
                                        .exception(value);
                                }
                            }
                        } else {
                            throw JDBCMessages.NOT_A_NAME.exception(value);
                        }

                        pointValue.setPointUUID(uuid);

                        break;
                    }
                    case POINT_NAME: {
                        final UUID uuid;

                        if (value instanceof String) {
                            try {
                                uuid = _connection
                                    .getPointUUID((String) value)
                                    .get();
                            } catch (final IllegalArgumentException exception) {
                                throw JDBCMessages.UNKNOWN_POINT
                                    .exception(value);
                            }
                        } else {
                            throw JDBCMessages.NOT_A_NAME.exception(value);
                        }

                        pointValue.setPointUUID(uuid);

                        break;
                    }
                    case POINT_UUID: {
                        final UUID uuid;

                        if (value instanceof UUID) {
                            uuid = (UUID) value;
                        } else if (value instanceof String) {
                            try {
                                uuid = UUID
                                    .fromString(value.toString())
                                    .orElse(null);
                            } catch (final IllegalArgumentException exception) {
                                throw JDBCMessages.NOT_A_UUID.exception(value);
                            }
                        } else {
                            throw JDBCMessages.NOT_A_UUID.exception(value);
                        }

                        pointValue.setPointUUID(uuid);

                        break;
                    }
                    case STAMP: {
                        final DateTime stamp;

                        if (value instanceof DateTime) {
                            stamp = (DateTime) value;
                        } else if (value instanceof String) {
                            try {
                                stamp = DateTime
                                    .fromString(Optional.of((String) value))
                                    .orElse(null);
                            } catch (final IllegalArgumentException exception) {
                                throw JDBCMessages.NOT_A_STAMP.exception(value);
                            }
                        } else {
                            throw JDBCMessages.NOT_A_STAMP.exception(value);
                        }

                        pointValue.setStamp(stamp);

                        break;
                    }
                    case STATE: {
                        pointValue.setState(value);

                        break;
                    }
                    case VALUE: {
                        pointValue.setValue(value);

                        break;
                    }
                    default: {
                        throw new InternalError("Unexpected column: " + column);
                    }
                }
            }

            pointValues[updates++] = pointValue;
        }

        Require.success(updates == pointValues.length);

        update(pointValues);
    }

    private void _fetchPointRows(
            final Request.Query request,
            final StoreResultSet resultSet)
        throws SQLException
    {
        final UUID[] uuids = _connection
            .getPointsUUID(request.prepareInfoQuery());
        final List<StoreColumn> columns = request.getColumns();

        if ((columns.size() == 1) && (columns.get(0) == StoreColumn.COUNT)) {
            resultSet.addRow(Integer.valueOf(uuids.length));
            getThisLogger()
                .debug(
                    JDBCMessages.POINTS_RETURNED,
                    String.valueOf(uuids.length));
        } else {
            int rows = 0;

            for (final UUID uuid: uuids) {
                final Object[] row = new Object[columns.size()];
                int columnNumber = 0;

                for (final StoreColumn column: columns) {
                    final Object value;

                    switch (column) {
                        case POINT_UUID: {
                            value = uuid;

                            break;
                        }
                        case POINT_NAME: {
                            value = _connection.getPointName(uuid).get();

                            break;
                        }
                        default: {
                            throw new InternalError(
                                "Unexpected column: " + column);
                        }
                    }

                    row[columnNumber++] = value;
                }

                resultSet.addRow(row);
                ++rows;

                if ((_maxRows > 0) && (rows >= _maxRows)) {
                    break;
                }
            }

            getThisLogger()
                .debug(JDBCMessages.POINT_ROWS_RETURNED, Integer.valueOf(rows));
        }
    }

    private LinkedList<Request.Update> _batch;
    private final AtomicBoolean _closed = new AtomicBoolean();
    private final int _concurrency;
    private final StoreConnection _connection;
    private boolean _escapeProcessing = true;
    private int _fetchSize;
    private final int _holdability;
    private volatile Logger _logger;
    private int _maxRows;
    private final Parser _parser = new Parser();
    private volatile StoreResultSet _resultSet;
    private final int _type;
    private int _updateCount = -1;
    private SQLWarning _warnings;
}

/* This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA
 */
